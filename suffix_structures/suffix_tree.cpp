/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author gainullin.ildar
 */

#include <bits/stdc++.h>

#include <cmath>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <list>
#include <time.h>
#include <math.h>
#include <random>
#include <deque>
#include <queue>
#include <cassert>
#include <unordered_map>
#include <iomanip>

using namespace std;


typedef long long ll;


struct node
{
	int suf;
	vector<int> go;
	int start;
	int parent;
	int depth;

	node()
	{
		suf = start = parent = depth = -1;
		go.resize(28, -1);
	}
};


const int N = 1e6 + 7;

node t[N];
int dp[N];
int l, r;
int v;
char s[N];
int sz = 1;
int inf = 1e9;
int cnt = 0;
ll sum = 0;
int cur = 0;

bool goDown()
{
	bool cr = false;
	if (t[v].depth != r - l)
	{
		int len = (r - l - t[t[v].parent].depth);
		if (s[r] != s[t[v].start + len])
		{
			int nv = sz++;
			t[nv] = node();
			t[nv].parent = t[v].parent;
			t[nv].depth = r - l;
			t[nv].start = t[v].start;
			t[t[v].parent].go[s[t[v].start]] = nv;
			t[nv].go[s[t[v].start + len]] = v;
			t[v].start += len;
			t[v].parent = nv;
			cr = true;
			v = nv;
		}
	}
	if (t[v].depth == r - l)
	{
		if (t[v].go[s[r]] == -1)
		{
			int nv = sz++;
			t[nv] = node();
			t[v].go[s[r]] = nv;
			t[nv].parent = v;
			t[nv].depth = inf;
			t[nv].start = r;
			cnt++;
			cr = true;
		}
		v = t[v].go[s[r]];
	}
	return cr;
}

void add(char c)
{
	s[r] = c;
	int alone = -1;
	while (l <= r)
	{
		bool cr = goDown();
		if (alone != -1)
		{
			t[alone].suf = t[v].parent;
			alone = -1;
		}
		if (!cr)
		{
			break;
		}
		v = t[v].parent;
		if (t[v].suf == -1)
		{
			alone = v;
			v = t[v].parent;
		}
		v = t[v].suf;
		l++;
		while (t[v].depth < r - l)
		{
			v = t[v].go[s[l + t[v].depth]];
		}
	}
	r++;
	sum += cnt;
}

void init()
{
	t[0] = node();
	t[0].parent = 0;
	t[0].depth = 0;
	t[0].suf = 0;
}
